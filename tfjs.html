<html>
  <head> </head>

  <body>
	<img hidden id="pcm16le" src="pcm16le.png" />
	<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.1.2/dist/tf.min.js"></script>
	<script>

	function frame(signal, frameLength, frameStep)
	{
		let start = 0;
		const output = [];
		while (start + frameLength <= signal.size)
		{
			output.push(signal.slice(start, frameLength));
			start += frameStep;
		}
		return tf.concat(output).as2D(output.length, frameLength);
	} 

	function stft_abs_sq(signal, nfft, frameLength, frameStep)
	{
		let framedSignal = frame(signal, frameLength, frameStep);
		framedSignal = tf.concat([framedSignal, tf.zeros([framedSignal.shape[0], nfft - framedSignal.shape[1]])], 1);
		const windowedSignal = tf.mul(framedSignal, tf.hannWindow(nfft));

		const output = [];
		for (let i = 0; i < framedSignal.shape[0]; i++)
			output.push(tf.square(tf.abs(tf.rfft(windowedSignal.slice([i, 0], [1, nfft])))));

		return tf.div(tf.concat(output), nfft);
	}

	function preemphasis(signal, coeff)
	{
		signal.arraySync();
		return tf.concat([tf.slice1d(signal, 0, 1), tf.sub(tf.slice1d(signal, 1, signal.size - 1), tf.mul(tf.slice1d(signal, 0, signal.size - 1), coeff))]);
	}
	
	function get_filterbanks(nfilt, nfft, samplerate)
	{
		const hz2mel = hz => 2595 * Math.log10(1+hz/700.);
		const mel2hz = mel =>  tf.mul(700, tf.sub(tf.pow(10, tf.div(mel, 2595)), 1));

		const lowfreq = 0;
		const highfreq = samplerate / 2;
		const lowmel = hz2mel(lowfreq);
		const highmel = hz2mel(highfreq);
		const melpoints = tf.linspace(lowmel,highmel,nfilt+2);
		const bin = tf.floor(tf.mul(nfft+1, tf.div(mel2hz(melpoints), samplerate))).arraySync();

		const fbank = tf.zeros([nfilt, nfft / 2 + 1]).arraySync();
		for(let j = 0; j < nfilt; j++)
		{
			for(let i = Math.floor(bin[j]); i < Math.floor(bin[j+1]); i++)
				fbank[j][i] = (i - bin[j]) / (bin[j+1]-bin[j])
			for(let i = Math.floor(bin[j+1]); i < Math.floor(bin[j+2]); i++)
				fbank[j][i] = (bin[j+2]-i) / (bin[j+2]-bin[j+1])
		}
		return tf.tensor(fbank);
	}

	(async () => {

		
		const sample_rate = 16000;
		const window_length = 20 * sample_rate / 1000;
		const hop_length = 10 * sample_rate / 1000;
		const nfft = 512;
		const nfilt = 64;

		const features = tf.tidy(() => {
			let signal = tf.browser.fromPixels(document.getElementById('pcm16le'), 4);
			signal = signal.reshape([-1, 2]).transpose();
			signal = signal.slice(1, 1).mul(tf.scalar(256, 'int32')).add(signal.slice(0, 1)).sub(tf.scalar(32768, 'int32')).squeeze();

			signal = preemphasis(signal.asType('float32'), 0.97);
			const pspec = stft_abs_sq(signal, nfft, window_length, hop_length);
			const mel_basis = get_filterbanks(nfilt, nfft, sample_rate).transpose();
			const features = tf.log(tf.add(tf.matMul(pspec, mel_basis), 1e-20));
			return features;
		});

		let batch = features.expandDims();
		//const m = tf.mean(features);
		//const s = tf.sqrt(tf.mean(tf.squaredDifference(features, m)));
		//batch = tf.div(tf.sub(batch, m), s);

		const modelUrl = 'w2l_plus_large_mp.tfjs/model.json';
		const model = await tf.loadLayersModel(modelUrl);
		const scores = model.predict(batch).squeeze(0);
		const decoded_greedy = scores.argMax(axis = 1).arraySync();

		const decoded_text = decoded_greedy.map(c => ({0 : ' ', 27 : "'", 28 : '|'})[c] || String.fromCharCode(c - 1 + 'a'.charCodeAt()));
		console.log('decoded text', decoded_text.join(''));
		const postproc_text = decoded_text.filter((c, i) => i == 0 || c != decoded_text[i - 1]).join('').replace(/\|/g, '');
		console.log('postproc text','<', postproc_text, '>')

	})();
	</script>
  </body>
</html>
